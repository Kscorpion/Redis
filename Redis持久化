1.RDB:(意外宕机不会触发[丢失数据太多],单机环境可以关闭[save注释掉],集群环境关不掉[因为主从就是通过RDB同步数据])
	1.将配置文件 对应的dir 路径写死,不能使用 ./ ,否则在不同目录启动redis-server时,会在当前启动目录寻找
  dump.rdb文件(配置项中dbfilename项设置文件名称),从而导致执行redis-cli后进行查询时,出现丢数据的情况。
  
	2.什么时候fork子进程去进行cow,或者什么时候出发rdb持久化机制？(其中1,2 都是调用bgsave命令)
		1)shutdown 时若没开启aof,则触发。
    
		2)配置文件中有默认的save配置 save 900 1 / save 300 100 等。(900秒/300秒内有1/100个更改则触发)
    
		3)手动执行命令 save(只管保存,其他不管,全部阻塞)/bgsave(redis会在后台异步进行快照操作,同时可
以响应客户端请求,生成一个临时dump持久化文件,生成完成后替换之前的dump持久化文件)

		4)flushall 也会触发,清空内存中和持久化文件中的数据。

2.AOF：(不会fork子进程,单机和集群环境都可关闭)
	1.记录的是命令行。
  
	2.持久化文件同样也在dir配置目录下,配置项中appendfilename项设置文件名称"appendonly.aof"。
  
	3.通过修改配置项进行启动 appendonly yes 表示,有三种触发机制(数据先写入AOF缓冲区[不会阻塞],再同步到磁盘)：
		1)no:表示等操作系统进行数据缓存同步到磁盘。(快,但持久化没保证)
		2)always:同步持久化,每次发生数据变更时,立刻记录到磁盘。(慢,但很安全)
		3)everysec:表示每秒同步一次。(默认配置,很快,但可能会丢失一秒以内的数据)
    
	4.AOF持久化文件中会有很多特殊符号,这个与redis中的协议有关(类似于解决tcp粘包拆包问题)
		1)例(select 0[切换到0数据库,默认16个])：
			*2 			#接下来有2组命令
			$6 			#接下来的命令字符串长度为6
			SELECT 	#查询操作
			$1 			#下一个命令字符串长度为1
			0 			#下一个命令字符串参数值
      
	5.redis重写机制(重写会fork子进程来完成[耗性能,相当于开了2个redis进程])：
		1)当AOF文件增长到一定大小时,Redis会调用bgrewriteaof对日志文件进行重写,当AOF文件大小的增长率大于
    该配置项是自动开启重写(这里指超过原文件大小的100%)
		auto-aof-rewrite-percentage 100
    
		2)当AOF文件增长到一定大小的时候,Redis会调用bgrewriteaof对日志文件进行重写,当AOF文件大小大于该配
    置项时会自动开启重写
		auto-aof-rewrite-min-size 64mb(一般不论大小公司都至少配置5G以上,减少fork子进程频率)

3.混合持久化：
	1.优化操作：一般会把RDB持久化的save配置下面两个默认的删除只保留save 900 1,因为频繁触发fork会占用CPU。
  
	2.4.0版本以后的混合持久化主要是对bgrewriteaof重写保存持久化文件内容进行改进,默认以RDB的方式保存,这样更节省空间,且之前是有换行符的。
